@page "/Items/ItemsList"
<div>
    <div class="uk-margin uk-flex uk-flex-between uk-flex-wrap">
        <div>
            
        </div>
        <div>
            @* //TODO: сделать поиск и показывать подходящие предметы *@
            <form class="uk-search" aria-label="Search">
                <div class="uk-panel-box-primary border-radius">
                    <input class="uk-search-field" type="search" placeholder="Поиск..." autocomplete="off">
                </div>
            </form>
            <div class="uk-inline">
                <button class="uk-button uk-button-primary border-radius" type="button"><i class="fa-solid fa-filter"></i></button>
                <div class="uk-panel-box-primary" uk-drop><div class="background"></div></div>
            </div>
        </div>
    </div>
    <div class="uk-panel-box full-space border-radius">
        <ul class="uk-grid-small uk-grid-match" uk-grid>

            @for (int i = 0; i < 50; i++)
            {
                Random r = new();
                int BuyValue = r.Next(1, 1000);
                int SellValue = r.Next(1, 1000);
                int Profit = SellValue - BuyValue;
                <li class="uk-width-1-6">
                    <div class="uk-panel-box-primary">

                        <h3 class="uk-card-title uk-text-center uk-text-top">Item @i</h3>
                        <img class="uk-align-center" src="_content/Warf_MAUI.Shared/svg/ducat_light.svg" alt="Item @i" width="64" height="64">
                        <div class="uk-text-center">
                            <p class="uk-text-normal">Цена покупки: @BuyValue</p>
                            <p class="uk-text-normal">Цена продажи: @SellValue</p>
                            <p class="uk-text-normal">Разница: @Profit</p>
                            <p class="uk-text-normal">Ранг: @r.Next(0, 10)</p>
                            <p class="uk-text-normal">Налог на торговлю: @FormatNumber(r.Next(1, 100_000_000))</p>
                            <p class="uk-text-normal">тренд цены:</p>
                            <p class="uk-margin-left">90 дней:</p>
                            <p class="uk-margin-left">2 дня:</p>
                        </div>
                    </div>
                </li>
            }

        </ul>
    </div>
</div>
@code {
    string FormatNumber(double value)
    {
        if (value >= 1_000_000)
            return $"{value / 1_000_000:0.#}M";
        if (value >= 1_000)
            return $"{value / 1_000:0.#}K";
        return value.ToString("0");
    }

    /*
     🧠 Общая цель класса BM25Searcher
    BM25Searcher — это полнотекстовый поисковый движок, реализующий алгоритм BM25 для ранжирования релевантности документов (в данном случае — item.Name). Также включает:

    Обратный индекс — для быстрого поиска по словам.

    TF / DF индексы — для расчёта BM25.

    Trie-дерево — для автодополнения.

    Левенштейн-исправление — для корректировки ошибок в запросах (например, опечаток).

    📦 Поля и их назначение
    Поле	Тип	Назначение
    items	List<dynamic>	Список всех добавленных элементов (документов)
    invertedIndex	Dictionary<string, List<int>>	Обратный индекс: слово → список itemId, где оно встречается
    termFrequencies	Dictionary<int, Dictionary<string, int>>	Слово → частота в конкретном документе
    documentFrequencies	Dictionary<string, int>	Слово → количество документов, где оно встречается
    autocompleteTrie	Trie	Trie-дерево для автодополнения
    avgDocLength	double	Средняя длина документа (по количеству слов)
    k1, b	double	Параметры BM25

    📚 Основные методы
    void Clear()
    Очищает все индексы и хранилища, сбрасывая внутреннее состояние.

    void AddItem(dynamic item)
    Добавляет один документ (item) в индекс:

    Разбивает item.Name на слова.

    Обновляет:

    invertedIndex

    termFrequencies

    documentFrequencies

    autocompleteTrie

    Перерасчитывает avgDocLength.

    void AddItems(IEnumerable<dynamic> items)
    Добавляет сразу несколько документов через вызов AddItem для каждого.

    List<dynamic> Search(string query)
    Основной метод поиска:

    Разбивает строку запроса на слова.

    Исправляет опечатки через FindClosestWord.

    Для каждого слова вычисляет BM25-рейтинг для всех релевантных документов.

    Сортирует документы по убыванию суммарного рейтинга и возвращает их.

    double CalculateBM25(int itemId, string term)
    Вычисляет значение BM25 по формуле:

    ini
    Копировать
    Редактировать
    BM25 = IDF(term) * TF(term)
    IDF(term) = логарифм отношения общего числа документов к количеству документов с этим словом.

    TF(term) = частотная формула с учётом длины документа (k1, b).

    string FindClosestWord(string word)
    Исправление опечаток по алгоритму Левенштейна:

    Перебирает все слова в invertedIndex.

    Возвращает ближайшее слово по расстоянию.

    int LevenshteinDistance(string s1, string s2)
    Реализация алгоритма вычисления расстояния Левенштейна (редакционного расстояния) между двумя строками.

    List<string> GetAutocompleteSuggestions(string prefix)
    Возвращает список слов, начинающихся с prefix, используя Trie.

    🌳 Вспомогательный класс Trie
    Простое Trie-дерево (префиксное дерево), позволяющее быстро:

    Вставлять слова (Insert)

    Получать все слова по префиксу (GetWordsWithPrefix)

    Внутренности Trie
    TrieNode — вершина дерева:

    Children — дочерние символы.

    IsEndOfWord — флаг конца слова.

    Метод Insert(string word)
    Добавляет слово посимвольно в дерево.

    Метод GetWordsWithPrefix(string prefix)
    Находит поддерево, соответствующее префиксу, и возвращает все возможные окончания (полные слова).

    📈 Алгоритм BM25 (подробнее)
    Параметры:

    k1 — степень насыщения по частоте терма (обычно 1.2–2.0)

    b — насколько сильно учитывать длину документа (0 = игнорировать, 1 = учитывать полностью)

    Формула:

    text
    Копировать
    Редактировать
    BM25 = idf * ((tf * (k1 + 1)) / (tf + k1 * (1 - b + b * (dl / avgdl))))
    tf — частота слова в документе

    dl — длина документа

    avgdl — средняя длина всех документов

    idf — логарифмическое значение обратной частоты документа

    ✅ Преимущества реализации
    Поддержка нечёткого поиска (ошибки, опечатки).

    Поддержка автодополнения по первым буквам.

    Высокое качество ранжирования за счёт BM25.

    Простота расширения под кастомные поля (можно заменить item.Name на item.Description, item.Tags и т. д.).

    🔧 Возможные улучшения
    Кеширование расстояний Левенштейна — особенно для больших словарей.

    Поддержка мультиязычности — токенизация по языковым правилам.

    Параллельный поиск — особенно при большом количестве документов.

    Разделение полей (Name, Tags, Type и т.д.) с весами.

    Фильтрация по дополнительным условиям (например, по цене, рангу и т. д.).
     */

    //TODO: перекинуть его в другую папку или\и класс он будет поьом использоваться еще в другой вкладке
    public class BM25Searcher
    {
        private readonly Dictionary<string, List<int>> invertedIndex = new(); // Обратный индекс
        private readonly List<dynamic> items = new();
        private readonly Dictionary<int, Dictionary<string, int>> termFrequencies = new();
        private readonly Dictionary<string, int> documentFrequencies = new();
        private readonly Trie autocompleteTrie = new(); // Trie для автодополнения
        private readonly double k1 = 1.5;
        private readonly double b = 0.75;
        private double avgDocLength;

        public void Clear()
        {
            items.Clear();
            invertedIndex.Clear();
            termFrequencies.Clear();
            documentFrequencies.Clear();
            autocompleteTrie.Clear();
            avgDocLength = 0;
        }

        public void AddItems(IEnumerable<dynamic> items)
        {
            foreach (var item in items) AddItem(item);
        }

        public void AddItem(dynamic item)
        {
            int itemId = items.Count;
            items.Add(item);
            var words = item.Name.ToLower().Split(' ', StringSplitOptions.RemoveEmptyEntries);

            var termCount = new Dictionary<string, int>();
            foreach (var word in words)
            {
                if (!termCount.ContainsKey(word)) termCount[word] = 0;
                termCount[word]++;

                if (!invertedIndex.ContainsKey(word)) invertedIndex[word] = new List<int>();
                if (!invertedIndex[word].Contains(itemId)) invertedIndex[word].Add(itemId);

                autocompleteTrie.Insert(word); // Добавляем слово в Trie
            }

            termFrequencies[itemId] = termCount;

            foreach (var word in termCount.Keys)
            {
                if (!documentFrequencies.ContainsKey(word)) documentFrequencies[word] = 0;
                documentFrequencies[word]++;
            }

            avgDocLength = items.Average(d => d.Name.Split(' ').Length);
        }

        public List<dynamic> Search(string query)
        {
            var queryWords = query.ToLower().Split(' ', StringSplitOptions.RemoveEmptyEntries);
            var correctedWords = queryWords.Select(FindClosestWord).ToList(); // Исправляем ошибки
            var scores = new Dictionary<int, double>();

            foreach (var word in correctedWords)
            {
                if (!invertedIndex.ContainsKey(word)) continue;
                foreach (var itemId in invertedIndex[word])
                {
                    double score = CalculateBM25(itemId, word);
                    if (!scores.ContainsKey(itemId)) scores[itemId] = 0;
                    scores[itemId] += score;
                }
            }

            return scores.OrderByDescending(s => s.Value)
                         .Select(s => items[s.Key])
                         .ToList();
        }

        private double CalculateBM25(int itemId, string term)
        {
            if (!termFrequencies[itemId].ContainsKey(term)) return 0;

            int termFrequency = termFrequencies[itemId][term];
            int docLength = items[itemId].Name.Split(' ').Length;
            int numDocs = items.Count;
            int docFrequency = documentFrequencies.ContainsKey(term) ? documentFrequencies[term] : 0;

            double idf = Math.Log(1 + (numDocs - docFrequency + 0.5) / (docFrequency + 0.5));
            double tf = (termFrequency * (k1 + 1)) / (termFrequency + k1 * (1 - b + b * (docLength / avgDocLength)));

            return idf * tf;
        }

        // Левенштейн для исправления ошибок
        private string FindClosestWord(string word)
        {
            int minDistance = int.MaxValue;
            string closestWord = word;

            foreach (var indexedWord in invertedIndex.Keys)
            {
                int distance = LevenshteinDistance(word, indexedWord);
                if (distance < minDistance)
                {
                    minDistance = distance;
                    closestWord = indexedWord;
                }
            }
            return closestWord;
        }

        private int LevenshteinDistance(string s1, string s2)
        {
            int[,] dp = new int[s1.Length + 1, s2.Length + 1];

            for (int i = 0; i <= s1.Length; i++)
                for (int j = 0; j <= s2.Length; j++)
                    if (i == 0) dp[i, j] = j;
                    else if (j == 0) dp[i, j] = i;
                    else
                        dp[i, j] = Math.Min(Math.Min(dp[i - 1, j] + 1, dp[i, j - 1] + 1),
                                            dp[i - 1, j - 1] + (s1[i - 1] == s2[j - 1] ? 0 : 1));

            return dp[s1.Length, s2.Length];
        }

        // Автодополнение
        public List<string> GetAutocompleteSuggestions(string prefix)
        {
            return autocompleteTrie.GetWordsWithPrefix(prefix.ToLower());
        }
    }

    // Trie-дерево для автодополнения
    public class Trie
    {
        private class TrieNode
        {
            public Dictionary<char, TrieNode> Children = new();
            public bool IsEndOfWord;
        }
        public void Clear()
        {
            root.Children.Clear();
        }

        private readonly TrieNode root = new();

        public void Insert(string word)
        {
            var node = root;
            foreach (char ch in word)
            {
                if (!node.Children.ContainsKey(ch))
                    node.Children[ch] = new TrieNode();
                node = node.Children[ch];
            }
            node.IsEndOfWord = true;
        }

        public List<string> GetWordsWithPrefix(string prefix)
        {
            var node = root;
            foreach (char ch in prefix)
            {
                if (!node.Children.ContainsKey(ch))
                    return new List<string>();
                node = node.Children[ch];
            }
            List<string> results = new();
            FindWords(node, prefix, results);
            return results;
        }

        private void FindWords(TrieNode node, string prefix, List<string> results)
        {
            if (node.IsEndOfWord) results.Add(prefix);
            foreach (var child in node.Children)
            {
                FindWords(child.Value, prefix + child.Key, results);
            }
        }
    }

}
